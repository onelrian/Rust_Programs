use crate::{absolute::absolute, multiplication::multiplication, sign::sign};

pub fn div(mut dividend: f64, mut divisor: f64, decimal_places: usize) -> f64 {
    if divisor == 0.0 {
        println!("Error: Division by zero");
        return 0.0;
    }

    let sign = sign(dividend, divisor);

    dividend = absolute(dividend);
    divisor = absolute(divisor);

    let mut quotient = 0.0;
    let mut remainder = dividend;

    while remainder >= divisor {
        remainder -= divisor;
        quotient += 1.0;
    }

    // Calculate the decimal part of the quotient
    let mut decimal_value = 0.0;
    let mut factor = 0.1;

    for _ in 0..decimal_places {
        remainder = multiplication(remainder, 10.0);
        let mut decimal_digit = 0.0;

        while remainder >= divisor {
            remainder -= divisor;
            decimal_digit += 1.0;
        }

        decimal_value += multiplication(factor, decimal_digit); // Fix: Directly add to decimal_value
        factor = multiplication(factor, 0.1); // Fix: Reduce factor correctly
    }

    let result = quotient + decimal_value;
    multiplication(result, sign as f64)
}

// Test case
fn main() {
    let dividend = 1.0;
    let divisor = 3.0;
    let decimal_places = 3;

    let result = div(dividend, divisor, decimal_places);
    println!("The quotient of {} and {} is {:.3}", dividend, divisor, result);
}